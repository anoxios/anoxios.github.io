{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome","text":"<p>This site hosts CTF writeups \u2013 step-by-step solutions for reverse engineering, crypto, and other challenges.</p>"},{"location":"#available-writeups","title":"Available writeups","text":"<ul> <li>Froggy CrackMe \u2013 Name/serial CrackMe with FNV + mix; single-jump patch or Z3 keygen (<code>froggy_solver.py</code>).</li> </ul> <p>Site built with MkDocs Material.</p>"},{"location":"writeups/froggy-crackme/","title":"Froggy CrackMe \u2013 Solution","text":"<p>Category: Reverse / CrackMe Tools: IDA Pro, Python, Z3</p>"},{"location":"writeups/froggy-crackme/#summary","title":"Summary","text":"<ul> <li>Serial format: <code>XXXXXXXX-XXXXXXXX-XXXXXXXX-XXXXXXXX</code> (32 hex digits, 3 dashes).</li> <li>Validation: Name and serial are combined via FNV-1a hashing and a splitmix64-style mix; a single final comparison decides success.</li> <li> <p>Elegant weakness: One conditional jump controls the outcome. Patching that jump makes the program accept any valid-format input.</p> </li> <li> <p>Challenge archive: Download froggy_crackme.zip</p> </li> <li>Solver script: froggy_solver.py (view or download the keygen source)</li> </ul>"},{"location":"writeups/froggy-crackme/#1-validation-flow-from-reversing","title":"1. Validation flow (from reversing)","text":"<ol> <li>Anti-debug: Reads <code>/proc/self/status</code>, checks <code>TracerPid:</code>. If non-zero \u2192 \"Debugger detected. The swamp rejects you.\"</li> <li>Input: Prompts for Name and Serial (format above).</li> <li>Serial parsing: 4 groups of 8 hex digits \u2192 two 64-bit values:</li> <li><code>v17 = (group1 &lt;&lt; 32) | group2</code></li> <li><code>v18 = (group3 &lt;&lt; 32) | group4</code></li> <li>Name hashes (FNV-1a, prime 0x100000001B3):</li> <li>Name \u2192 hash \u2192 <code>v29 = hash ^ 0xA3B1957C4D2E1901</code></li> <li>Reversed name \u2192 hash \u2192 <code>v47 = hash ^ 0xC0D0E0F112233445</code></li> <li>Empty name: <code>v29 = 0xB7D49ACC3EB31A82</code>, <code>v47 = 0xD4B5EF4161BE37C6</code></li> <li>Final check: A chain of splitmix64-style mix and XOR/add uses <code>v29</code>, <code>v47</code>, <code>v17</code>, <code>v18</code> and compares the result to <code>0xB9229933597558C9</code>.</li> <li>In the binary: <code>cmp rcx, rax</code> at 0x2731 (rax = 0xB9229933597558C9), then a conditional jump (failure path).</li> </ol>"},{"location":"writeups/froggy-crackme/#2-single-path-elegant-weakness","title":"2. Single path / elegant weakness","text":"<p>Success is decided by one comparison and one conditional jump:</p> <ul> <li>0x2731: <code>cmp rcx, rax</code> (computed value vs 0xB9229933597558C9)</li> <li>0x2734: conditional jump (e.g. <code>jnz</code> to \"Wrong incantation\" at 0x27ac)</li> </ul> <p>If the jump is never taken, execution always reaches \"The Swamp Gate opens.\"</p>"},{"location":"writeups/froggy-crackme/#patch-elegant-crack","title":"Patch (elegant crack)","text":"<ul> <li>File: <code>froggy_crackme</code> (or your copy).</li> <li>Location: the 2-byte instruction immediately after <code>cmp rcx, rax</code> (the conditional jump at 0x2734).</li> <li>Original: conditional jump (e.g. <code>75 xx</code> = <code>jnz</code>).</li> <li>Patch: replace those 2 bytes with <code>90 90</code> (two NOPs).</li> </ul> <p>Then:</p> <ul> <li>Run without a debugger (or with TracerPid cleared).</li> <li>Enter any non-empty name and any serial in the correct format, e.g. Name: <code>Froggy</code> Serial: <code>00000000-00000000-00000000-00000000</code></li> </ul> <p>The program will always open the gate.</p>"},{"location":"writeups/froggy-crackme/#3-finding-a-valid-key-no-patch-z3-keygen","title":"3. Finding a valid key (no patch) \u2013 Z3 keygen","text":"<p>To get a real name+serial pair that passes the check without patching we model the check in Z3 and solve for the four 32-bit serial parts.</p> <p>The solver <code>froggy_solver.py</code> does the following:</p> <ol> <li>From the name: Compute FNV-1a hashes for name and reversed name, then apply the known XORs to get <code>v29</code> and <code>v47</code>.</li> <li>fmix-like: Reconstruct the binary\u2019s mix (without the final <code>^ (x &gt;&gt; 32)</code> where applicable) for intermediate values; the final comparison uses <code>final_mix(x) = fmix_like(x) ^ (fmix_like(x) &gt;&gt; 32)</code> compared to <code>TARGET</code>.</li> <li>Serial as unknowns: The serial is 4 groups of 8 hex digits \u2192 four 32-bit values <code>p0, p1, p2, p3</code> with:</li> <li><code>v17 = (p0 &lt;&lt; 32) | p1</code></li> <li><code>v18 = (p2 &lt;&lt; 32) | p3</code></li> <li>Formula: Build the rest of the binary\u2019s formula (v54, v55, v56, v57, v58) from the decompiled logic and add the constraint <code>final_mix(v58) == TARGET</code>.</li> <li>Z3: Use bit-vector solver (<code>QF_BV</code>) with multiple random seeds and timeouts to find a satisfying assignment for <code>p0..p3</code>, then format the serial as <code>XXXXXXXX-XXXXXXXX-XXXXXXXX-XXXXXXXX</code>.</li> </ol>"},{"location":"writeups/froggy-crackme/#usage","title":"Usage","text":"<p>Download the solver: froggy_solver.py, then:</p> <pre><code>python3 froggy_solver.py\n</code></pre> <p>Enter a name when prompted (e.g. <code>Froggy</code>). The script prints a valid serial. It tries a 15s timeout first, then 60s if needed.</p> <p>Dependencies: <code>z3-solver</code> (<code>pip install z3-solver</code>).</p>"},{"location":"writeups/froggy-crackme/#relevant-code-excerpt","title":"Relevant code (excerpt)","text":"<p>Constants are taken from the binary (TARGET, FNV init/prime, XOR constants, fmix P/Q). The core is:</p> <ul> <li><code>fnv1a64(data)</code> \u2013 FNV-1a 64-bit hash.</li> <li><code>fmix_like(x)</code> \u2013 mix used for v52, v53, v57 (no final xor with &gt;&gt;32).</li> <li><code>final_mix(x)</code> \u2013 value compared to TARGET: <code>fmix_like(x) ^ (fmix_like(x) &gt;&gt; 32)</code>.</li> <li><code>solve_for_name(name, per_seed_timeout_ms)</code> \u2013 builds the Z3 model and returns a serial string or <code>(None, None)</code>.</li> </ul>"},{"location":"writeups/froggy-crackme/#4-quick-reference","title":"4. Quick reference","text":"Item Value / Location Target constant <code>0xB9229933597558C9</code> Comparison <code>cmp rcx, rax</code> at 0x2731 Patch Replace conditional jump at 0x2734 with <code>90 90</code> Success message \"The Swamp Gate opens.\" / \"Froggy approves.\""}]}